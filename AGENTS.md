# AGENTS.md - Elite City Builder

This document provides guidance for AI developers working on the Elite City Builder project.

## Project Overview

The goal is to create a city-building game with an aesthetic inspired by the wireframe graphics and minimalist UI of the 1984 game Elite. Key features include resource management, building placement, power simulation, and a save/load system.

## Coding Conventions and Style

*   **Python:** Follow PEP 8 guidelines for Python code.
*   **Type Hinting:** Use type hints for function signatures and important variables to improve code clarity and maintainability.
*   **Modularity:** Keep classes and modules focused on specific responsibilities.
    *   `city.py` for overall city state and high-level logic.
    *   `buildings.py` for individual building data and behavior.
    *   `ui.py` for all rendering and user interface elements.
    *   `config.py` for static configurations, building specs, game balance numbers.
    *   `main.py` for the main game loop, event handling, and tying modules together.
*   **Comments:** Write clear comments for complex logic or non-obvious code sections. Docstrings should explain the purpose of classes and functions.
*   **Error Handling:** Implement robust error handling, especially for file I/O (save/load) and user inputs. Provide informative messages when errors occur.

## Elite 1984 Aesthetic

*   **Graphics:**
    *   Primarily wireframe. Lines should be thin and typically monochrome (e.g., green, white, or light blue on a black background).
    *   Avoid filled shapes unless absolutely necessary for clarity (e.g., a small filled indicator).
    *   Keep building designs simple and geometric. Distinct silhouettes are important.
    *   No textures or complex lighting.
*   **UI:**
    *   Minimalist. Use simple text and lines.
    *   Information should be clearly presented but without excessive decoration.
    *   Font should be a clean, possibly monospaced or "computery" system font.
    *   Color palette should be limited, consistent with the wireframe graphics.

## Key Data Structures

*   **`Building` class (`buildings.py`):** Represents individual structures. Contains attributes like type, position, cost, power generation/consumption, population capacity, etc.
*   **`City` class (`city.py`):** Manages the collection of buildings, overall city resources (credits, power, population, ore), city value, and rank. It also handles the grid for building placement.
*   **`BUILDING_SPECS` in `config.py`:** A dictionary defining the properties of each building type. This is the central place to add new buildings or balance existing ones.
    *   When adding a new building, ensure all relevant keys are present (cost, power, size, char, unlock_rank, value, etc.).

## Game Mechanics Guidance

*   **Power Simulation:**
    *   Buildings can generate or consume power.
    *   The city has a net power balance.
    *   If power consumption exceeds generation (negative net power), some buildings must become non-operational. The current logic in `City.update_resources()` deactivates high-consumption buildings first. This can be refined.
    *   Non-operational buildings do not provide their benefits (e.g., no population capacity, no resource generation).
*   **Resource Management:**
    *   **Credits:** Primary currency for building. Generated by population (current simple model).
    *   **Population:** Grows based on available capacity from operational habitats and positive net power.
    *   **Ore:** Actively produced by operational mining buildings (e.g., `ORE_MINE_BASIC`). It contributes to city value and can be used as a cost for future advanced buildings.
*   **Building Placement:**
    *   Buildings occupy tiles on a grid.
    *   Check for affordability, grid boundaries, and collisions before placing.
    *   The `City` class maintains a `grid` attribute for quick collision checks.
*   **City Rank:**
    *   Determined by `city_value`.
    *   `city_value` is calculated from the value of buildings, credits, population, etc.
    *   Higher ranks unlock new building types (defined in `BUILDING_SPECS` and checked by `get_available_buildings` in `buildings.py`).

## Adding New Features

*   **New Buildings:**
    1.  Define the building in `config.py` under `BUILDING_SPECS`. Include all necessary attributes (cost, power, size, character representation, unlock rank, value, and any special properties like `population_cap` or `ore_prod`).
    2.  If the building has new unique mechanics, update `Building` class in `buildings.py` and `City.update_resources()` in `city.py` to account for them.
    3.  Update `UIManager` in `ui.py` if special rendering is needed (beyond the default character and wireframe box).
    4.  Add new building type to `get_available_buildings` logic if it depends on rank.
    5.  Add unit tests for the new building's effects in `test_buildings.py` and `test_city.py`.
*   **New Game Mechanics:**
    1.  Consider which module is most appropriate (e.g., city-wide effects in `city.py`, specific interactions in `buildings.py`).
    2.  Implement the logic.
    3.  Update UI (`ui.py`) to display any new information.
    4.  Update save/load (`save_load.py`, `City.to_dict/from_dict`, `Building.to_dict/from_dict`) if new persistent data is involved.
    5.  Write unit tests.

## Testing

*   Unit tests are located in the `city_builder/tests/` directory.
*   Use the `unittest` module.
*   Write tests for:
    *   Core game state changes in `City` (resource updates, building addition/removal).
    *   `Building` class logic (attribute correctness, serialization).
    *   Save/load functionality.
    *   Rank progression.
    *   Power simulation edge cases (e.g., shortages).
*   Run tests frequently during development: `python -m unittest discover city_builder/tests`

## Sound

*   The `SoundManager` in `sound.py` is used.
*   To add new sound events:
    1.  Identify a unique name for the sound (e.g., "research_complete").
    2.  Ensure the corresponding `.wav` file is expected in `city_builder/assets/sounds/`.
    3.  In `main.py` (or relevant module), load the sound using `sound_manager.load_sound("research_complete", "city_builder/assets/sounds/research_complete.wav")`.
    4.  Trigger the sound using `sound_manager.play("research_complete")` where appropriate.
*   Users are expected to provide their own sound files. The game should function without them (printing warnings).

## Future Considerations (for AI developer awareness)

*   **Performance:** For very large cities, rendering too many individual lines or iterating through all buildings every frame might become slow. Consider optimizations if performance becomes an issue (e.g., spatial partitioning for rendering, dirty flags for UI updates).
*   **Extensibility:** Design components (like building effects) in a way that's relatively easy to extend with new types of effects without major refactoring. (e.g. a more component-based or event-driven architecture for building effects could be a future refactor if complexity grows significantly).

Remember to update this `AGENTS.md` file if significant architectural changes are made or new conventions are established.
